[{"title":"GO语言NonBlock-channel结构使用与总结","url":"/2018/06/02/GO语言NonBlock-channel结构使用与总结/","content":"最近在阅读一个项目的Go源码，发现一个很实用的Go channel结构，它可以实现非阻塞的更新channel里面的内容，非常适用一些特定的场景。\n\n\n首先简单介绍一下背景。为了便于描述，将程序抽象成为三个模块，分别为：主模块，模块一，模块二。\n{% asset_img go_channel.png 图1：模块关系 %}\n它们三者之间的关系如上图所示：模块一需要不断的将传输的进度信息更新到主模块，主模块将进度信息分别显示到界面和更新到模块二，模块二收到进度信息后，将进度信息再通过网络传给该网络中的其他节点。为了实现这个功能，很容易想到使用Go语言的channel来传递进度信息，然而，如果直接使用channel结构，就需要在每个模块对进度信息的更新进行同步，比较繁琐。\n\n\n在源码中使用了一个非阻塞的channel结构来更新进度信息。结构如下：\n{% codeblock lang:Golang %}\ntype NonBlock struct{\n\tcin chan string\n\tcou chan string\n}\n\nfunc NewNonBlock()*NonBlock{\n\tnbc := NonBlock{make(chan string), make(chan string)}\n\tvar v string\n\tgo func(){\n\t\tfor{\n\t\t\tselect{\n\t\t\t\tcase v = <- nbc.cin:\n\t\t\t\tcase nbc.cou <- v: \n\t\t\t}\n\t\t}\n\t}()\n\treturn &nbc\n}\nfunc (nbc *NonBlock)Send(v string){\n\tnbc.cin <- v\n}\nfunc (nbc *NonBlock)Recieve()string{\n\treturn <-nbc.cou\n}\n{% endcodeblock %}\n\n\n在`NonBlock`结构中使用了两个无缓冲的channel,分别负责进度信息的写入和读出。并且提供`Send()`和`Recieve()`方法，通过这两个方法向channel中写入进度信息。这个结构最关键的部分就在于初始化NonBlock结构的方法，在初始化方法中，开启了一个goroutine来不断的将写入到`cin`channel中的进度信息读出，这样一方面可以防止外部在写入进度信息时阻塞，因为这是一个无缓冲的channel。另一方面，当有外部程序调用`Recieve()`方法读取进度信息时，从`cin`读出的信息又被立即写到`cou`中，供外部读取。同样，外部读取数据也可以实现非阻塞，即使是在一开始就读取进度信息，初始化中的goroutine也可以把一个空的`v`写入到`cou`中。\n\n读到这里，你应该明白前面说的这种结构适用与一些特定的场景是什么意思了。假设，外部不断有进度信息写入而没有进行读出操作，那么这样就会造成变量`v`的数值不断的进行刷新，此时外部再过来读取进度的时候只能读取到最新的进度信息。然而，这个特性对本文的这个应用场景并没有影响，因为进度信息本来就需要最新的。可以简单的写个程序验证一下：\n{% codeblock lang:Golang %}\nfunc main(){\n\tnbc := NewNonBlock()\n\tstopflag := make(chan bool)\n\tgo func(){\n\t\tfor i:=0;i<10;i++{\n\t\t\tnbc.Send(fmt.Sprint(i))\n\t\t}\n\t\tstopflag <- true\n\t}()\n\t<- stopflag\n\tfmt.Println(\"Recieve value\" nbc.Recieve())\t\n}\n{% endcodeblock %}\n程序最终输出：\n{% codeblock lang:Golang %}\nRecieve value  9\n{% endcodeblock %}","tags":["Golang non-block channel"]},{"title":"Go interface","url":"/2018/05/01/Go-interface/","content":"in wikipied what is interface\ncommunicate unrelated object\n\n\n\nGopher china\n\n\n# 基本概念 #\nabtract types\nconcrete type\n\nmemory layout\nbehavior attacherd to data through methods\n\n\ndescrible behavior\n\nthe define a set of methods,withour specifi  revi\n\nabstratatrion\n\nunion of interface\ntwo style\n\nGo proverbs\n\n\nwhy do we use interface\n\nwrit generic algorit\nhindin details\nproviding interceprion points\n\n\nfunc Writer\n\nthe bigger the interface the weaker the abstration\n\nbe conservative in waht you be ,be liberak ub waht you accept\nTCP\n  call dispatch\n\n\nAbstract Data Types\n\nMathmaticak model for data tyoe \ndefined \n\n\n\n\n\n\n\nGo中的接口（interface）不描述数据，它只描述行为，它指定了一个类型（Type）的行为。定义一个interface,使用关键字type和interface,\n\n`type Write interface{\n\twrite([]byte) (int, error)\n}`\n\nType ConsoleWriter struct {}\n和其他语言不同，Go不提供显示implement接口的关键字，而是通过给ConsoleWriter类型绑定一个和接口一样签名的方法来隐式的impelement接口。\n\n    func (cw ConsoleWriter) Write (data []byte) (int, error){\n\t\tn,err:==fmt.println(string(data))\n\t\treturn n,err\n}\n\n命名规则，\n\n# composing interfaces #\n# type conversion #\n## the empty interface ##\n## type switches ##\n# implementing with values vs .pointers #\n\n# best prcatices #"},{"title":"Hello World","url":"/2018/05/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]
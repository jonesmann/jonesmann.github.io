[{"title":"长沙2日游规划","url":"/2020/06/26/长沙2日游规划/","content":"# 行程 #\n暂定周六周日两天，具体时间待定。总体时间规划如下:\n\n- 周六12:00到达长沙\n- 周六13:30到达五一广场，14:30完成入住\n- 周六3:30到达岳麓山，17:30完成参观\n- 周六19:30完成橘子洲头参观\n- 周六20:20返回五一广场，22:30逛完夜市回酒店\n- 周天10:00起床，10:30完成退房，11:00到达省博物馆，13:30博物馆出发去长沙南，搭乘2:10的高铁\n\n\n# 来程 #\n深圳出发：周六早上乘坐`G1004`列车，预计11:45到达。\n\n{% asset_img shenzhen.png 图1：深圳出发 %}\n武汉出发：周六早上乘坐`G1035`列车，预计12:09到达。\n\n{% asset_img wuhan.png 图2：武汉出发 %}\n# 住宿 #\n住宿网上推荐住五一广场附近，因为当前长沙有两条地铁线，两条地铁线共同站就是五一广场，橘子洲岳麓山都是地铁直达，另外长沙最有名的太平街坡子街黄兴步行街都在五一广场附近，方便吃逛。另外附近民宿或者酒店较多，暂时不预定。从长沙南到五一广场大约30min,预计13:30到达酒店，酒店完成办理入住大约2:30可以出门。\n\n{% asset_img changsha1.png 图3：五一广场 %}\n# 景点 #\n[***岳麓山(day1)***](https://baike.baidu.com/item/%E5%B2%B3%E9%BA%93%E5%B1%B1 \"岳麓山\")\n\n从五一广场乘地铁到岳麓山大约30min,可以在3点钟到达。从东门上山做缆车，下山可以步行，路上可以看见湘江和橘子洲头。该部分时间不定，预计2个半小时。可以在5:30完成参观。\n\n[***橘子洲头(day1)***](https://baike.baidu.com/item/%E6%A9%98%E5%AD%90%E6%B4%B2/440031?fromtitle=%E6%A9%98%E5%AD%90%E6%B4%B2%E5%A4%B4&fromid=315218 \"橘子洲\")\n\n\n橘子洲是一个小岛，面积还是很可观的，因为湘江橘子洲大桥，大约把湘江橘子洲岛分成了两部分，北边以停车为主，南面是毛泽东主题公园。据说偶尔有灯展。重大节日的夜晚，橘子洲公园上都将上演一场绚丽多彩的焰火晚会。不知道去的时间能不能赶得上。预计2个小时完成参观。7:30完成参观，8点20前能返回五一广场，逛夜市。\n\n{% asset_img mao.jpg 图5：雕像 %}\n\n[***湖南省博物馆(day2)***](http://www.hnmuseum.com/zh-hans \"博物馆\")\n\n\n开放时间：每周二至周日9:00—17:00（16:00停止入馆），每周一为闭馆日（逢法定节假日顺延）\n\n参观方式：疫情期间，我馆仅提供个人网络实名制预约，每天限额2000人。您可提前三天（含当天），登陆湖南省博物馆官网、官方APP、微信公众号进行预约，预约成功后，请您凭预约短信、有效证件及健康码入馆参观；未成功线上预约的观众谢绝入馆。预约观众参观时请携带好身份证等有效证件，否则无法入馆参观\n\n# 吃 #\n长沙太平街小弄堂里的美味，很多人慕名而来，人气很火爆，小小的巷子经常排着长长的队。从橘子洲就回到太平街逛小吃。\n\n- 王嗲刮凉粉\n- 正哥牛肉串\n- 黑色经典臭豆腐\n- 胡记炸炸炸\n- ...\n\n大约10:30回到酒店休息，完成周六一天的逛吃任务。（ps. 图片先空着）\n\n\n# 返程 #\n第二天早上10:00起，30min完成退房，10:30出发到省博物馆。11:00可以到达博物馆。从省博物馆到长沙南站大约需要40min，因此13:30前从省博物馆出发到长沙南站。返回深圳：`G73`列车，14:19出发，预计17:54到达。返回武汉：`G836`列车，14:12出发，预计15:38到达。","tags":["生活"]},{"title":"Leetcode 763 Partition Labels 分割标签","url":"/2020/06/26/Leetcode-763-Partition-Labels-分割标签/","content":"\n# 题目描述 #\nA string S of lowercase English letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.\n\n- [Partition Labels](https://leetcode.com/problems/partition-labels/ \"Partition Labels\")\n\n# 解题思路 #\n输入为字符串, 字符串中有重复的字符，现在需要将这个字符串尽可能分割成多份，但是要保证每个字符只能出现中其中一个分割中，典型的贪心算法。\n\n先对字符串进行预处理，通过字典将每个字符在字符串中最大的index存储下来。时间复杂度O(n)。然后通过遍历字符串实现字符分割，具体为：获取字符串的第一个字符，并根据字典获取该字符的最大index，那么默认的切割为当前的字符位置到最大index位置，但这里会存在一个问题，即会存在在这个切割中有其他字符使得该字符的最大index大于前面字符的最大index，因此继续遍历字符串，如果发现遍历的index大于当前最大的index则重新赋值最大index，直到最终遍历的字符串index大于最大的index，即完成一次分割。时间复杂度为O(n)。因此该算法总体时间复杂度为O(n)。\n# Python实现 #\n{% codeblock lang:python %}\nclass Solution:\n    def partitionLabels(self, S: str):\n\t# 可以考虑使用defaultdict\n        sdict = {}\n        # 获取字符最长index, \n        for index, key in enumerate(S):\n            if key not in sdict.keys():\n                sdict[key] = index\n            else:\n                sdict.update({key: index})\n\n        remind = S[:]\n        index_list = []\n        last_index = 0\n\n        while remind:\n            index = sdict[remind[0]]\n            for i, c in enumerate(remind):\n                if last_index + i == index:\n                    remind = remind[i+1:]\n                    index_list.append(len(S[last_index:index+1]))\n                    last_index = index + 1\n                    break\n                elif sdict[c] > index:\n                    index = sdict[c]\n\n        return index_list\n{% endcodeblock %}","tags":["Leetcode"]},{"title":"树的基本知识总结","url":"/2018/06/17/树的基本知识总结/"},{"title":"Golang defer在channel中的一个简单应用","url":"/2018/06/03/Golang defer在channel中的一个简单应用/","content":"# 简介 #\n\n`Defer`用来确保被调用的函数能够在程序运行完成后被执行，通过是被用来做一些清理的工作，比如流的关闭或者是channel的关闭。基本和java中的finally类似。\n# 简单的例子 #\n假设打开一个文件，并且读出文件内容，最后完成后关闭文件，这里就可以使用defer语句来关闭文件：\n{% codeblock lang:golang %}\nfunc main() {\n\ttmpfile, err := os.Open(\"main.go\")\n\tif err != nil {\n\t\tlog.Fatal(\"%v\", err)\n\n\t}\n\tdefer tmpfile.Close()\n\tfileinfo, _ := tmpfile.Stat()\n\tfmt.Print(fileinfo.Size())\n\tbuff := make([]byte, 100)\n\tsize, err := tmpfile.ReadAt(buff, 2197)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Printf(\"%x\", buff[:size])\n\tfmt.Print(\"content is \", string(buff[:size]))\n}\n{% endcodeblock %}\n# channel中应用defer #\n先简单介绍以下Golang中的扇入(fan-in)和扇出(fan-out)。扇出表示多个函数可以从一个相同的channel中读数据一直到这个channel被关闭。而扇入则表示多个channel的数据可以被同一个函数读取和处理，然后合并到一个channel，直到所有channel都关闭。\n本文主要介绍在扇出，下面介绍通过一个channel来控制多个goroutine结束，在实际比较常用：\n{% codeblock lang:Golang %}\nfunc test1(done chan struct{}) {\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\tfmt.Println(\"test1\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc test2(done chan struct{}) {\n\tfor {\n\t\tselect {\n\t\tcase <-done:\n\t\t\tfmt.Println(\"test2\")\n\t\t\treturn\n\t\t}\n\t}\n}\nfunc test() {\n\tdone := make(chan struct{})\n\tgo test1(done)\n\tgo test2(done)\n    done <- struct{}{}\n    done <- struct{}{}\n}\n{% endcodeblock %}\n\n\n在上面的例子中，通过`done`来控制每个goroutine的结束，最后在需要根据有多少个goroutine来决定对`done`写入几次，这样的处理明显不够优雅。可以通过defer语句来解决这个问题，使用defer在函数完成后直接关闭channel,而在一个已关闭 channel上执行接收操作(<-ch)总是能够立即返回，返回值是对应类型的零值。\n{% codeblock lang:Golang %}\nfunc test() {\n\tdone := make(chan struct{})\n    defer close(done)\n\tgo test1(done)\n\tgo test2(done)\n}\nfunc main() {\n\ttest()\n\ttime.Sleep(time.Second)\n}\n{% endcodeblock %}\n\n可以通过看到输出，两个goroutine都被成功关闭\n{% codeblock lang:Golang %}\nPS D:\\GO\\src\\main> go run .\\intertest.go\ntest1\ntest2\nPS D:\\GO\\src\\main>\n{% endcodeblock %}\n\n\n"},{"title":"GO语言NonBlock-channel结构使用与总结","url":"/2018/06/02/GO语言NonBlock-channel结构使用与总结/","content":"最近在阅读一个项目的Go源码，发现一个很实用的Go channel结构，它可以实现非阻塞的更新channel里面的内容，非常适用一些特定的场景。\n\n\n首先简单介绍一下背景。为了便于描述，将程序抽象成为三个模块，分别为：主模块，模块一，模块二。\n{% asset_img go_channel.png 图1：模块关系 %}\n它们三者之间的关系如上图所示：模块一需要不断的将传输的进度信息更新到主模块，主模块将进度信息分别显示到界面和更新到模块二，模块二收到进度信息后，将进度信息再通过网络传给该网络中的其他节点。为了实现这个功能，很容易想到使用Go语言的channel来传递进度信息，然而，如果直接使用channel结构，就需要在每个模块对进度信息的更新进行同步，比较繁琐。\n\n\n在源码中使用了一个非阻塞的channel结构来更新进度信息。结构如下：\n{% codeblock lang:Golang %}\ntype NonBlock struct{\n\tcin chan string\n\tcou chan string\n}\n\nfunc NewNonBlock()*NonBlock{\n\tnbc := NonBlock{make(chan string), make(chan string)}\n\tvar v string\n\tgo func(){\n\t\tfor{\n\t\t\tselect{\n\t\t\t\tcase v = <- nbc.cin:\n\t\t\t\tcase nbc.cou <- v: \n\t\t\t}\n\t\t}\n\t}()\n\treturn &nbc\n}\nfunc (nbc *NonBlock)Send(v string){\n\tnbc.cin <- v\n}\nfunc (nbc *NonBlock)Recieve()string{\n\treturn <-nbc.cou\n}\n{% endcodeblock %}\n\n\n在`NonBlock`结构中使用了两个无缓冲的channel,分别负责进度信息的写入和读出。并且提供`Send()`和`Recieve()`方法，通过这两个方法向channel中写入进度信息。这个结构最关键的部分就在于初始化NonBlock结构的方法，在初始化方法中，开启了一个goroutine来不断的将写入到`cin`channel中的进度信息读出，这样一方面可以防止外部在写入进度信息时阻塞，因为这是一个无缓冲的channel。另一方面，当有外部程序调用`Recieve()`方法读取进度信息时，从`cin`读出的信息又被立即写到`cou`中，供外部读取。同样，外部读取数据也可以实现非阻塞，即使是在一开始就读取进度信息，初始化中的goroutine也可以把一个空的`v`写入到`cou`中。\n\n读到这里，你应该明白前面说的这种结构适用与一些特定的场景是什么意思了。假设，外部不断有进度信息写入而没有进行读出操作，那么这样就会造成变量`v`的数值不断的进行刷新，此时外部再过来读取进度的时候只能读取到最新的进度信息。然而，这个特性对本文的这个应用场景并没有影响，因为进度信息本来就需要最新的。可以简单的写个程序验证一下：\n{% codeblock lang:Golang %}\nfunc main(){\n\tnbc := NewNonBlock()\n\tstopflag := make(chan bool)\n\tgo func(){\n\t\tfor i:=0;i<10;i++{\n\t\t\tnbc.Send(fmt.Sprint(i))\n\t\t}\n\t\tstopflag <- true\n\t}()\n\t<- stopflag\n\tfmt.Println(\"Recieve value\" nbc.Recieve())\t\n}\n{% endcodeblock %}\n程序最终输出：\n{% codeblock lang:Golang %}\nRecieve value  9\n{% endcodeblock %}","tags":["Golang non-block channel"]},{"title":"Go interface","url":"/2018/05/01/Go-interface/","content":"In wikipidia, what is interface:\n\n*[communicate unrelated object](https://en.wikipedia.org/wiki/Interface_(computing)*\n\n# 基本概念 #\n抽象数据类型（abtract types）\n\n-   to be continue...\n\n实体类型（concrete type）\n\n-   to be continue...\n\n为什么使用interface\n\n- writ generic algorithm\n- hidden details\n- providing interception points\n\n\nGo中的接口（interface）不描述数据，它只描述行为，它指定了一个类型（Type）的行为。定义一个interface,使用关键字type和interface,\n\n`type Write interface{\n\twrite([]byte) (int, error)\n}`\n\nType ConsoleWriter struct {}\n和其他语言不同，Go不提供显示implement接口的关键字，而是通过给ConsoleWriter类型绑定一个和接口一样签名的方法来隐式的impelement接口。\n{% codeblock lang:golang %}\n    func (cw ConsoleWriter) Write (data []byte) (int, error) {\n\t\tn,err := fmt.println(string(data))\n\t\treturn n,err\n}\n{% endcodeblock %}\n# 命名规则 #\n\n- composing interfaces\n- type conversion \n- the empty interface\n- type switches\n- implementing with values vs pointers\n- best prcatices \n- to be cotinue...","tags":["Gopher china keynote talk."]},{"title":"Hello World","url":"/2018/05/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]
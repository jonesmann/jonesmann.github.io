[{"title":"GO语言NonBlock-channel结构使用与总结","url":"/2018/06/02/GO语言NonBlock-channel结构使用与总结/","content":"最近在阅读一个项目的Go源码，发现一个很实用的Go channel结构，它可以实现非阻塞的更新channel里面的内容，非常适用一些特定的场景。\n\n\n首先简单介绍一下背景。为了便于描述，将程序抽象成为三个模块，分别为：主控模块，链路发现模块，内容传输模块。\n{% asset_img go_chanel.png 图1：模块关系 %}\n它们三者之间的关系如图1所示：内容传输模块需要不断的将传输的进度信息更新到主控，主控将进度信息分别显示到界面和更新到链路传输模块，链路传输模块收到进度信息后，进度信息在通过网络传给该链路的父节点。为了实现这个功能，很容易想到使用Go语言的channel来传递进度信息，然而，如果直接使用channel结构，就需要在每个模块对进度信息的更新进行同步，比较繁琐。\n\n\n在源码中使用了一个非阻塞的channel结构来更新进度信息。结构如下：\n{% codeblock lang:Golang NonBlock struct %}\ntype NonBlock struct{\n\tcin chan string\n\tcon chan string\n}\n\nfunc NewNonBlock()*NonBlock{\n\tnbc := NonBlock{make(chan string), make(chan string)}\n\tvar v string\n\tgo func(){\n\t\tfor{\n\t\t\tselect{\n\t\t\t\tcase v = <- nbc.cin:\n\t\t\t\tcase nbc.con <- v: \n\t\t\t}\n\t\t}\n\t}()\n\treturn &nbc\n}\nfunc (nbc *NonBlock)Send(v string){\n\tnbc.cin <- v\n}\nfunc (nbc *NonBlock)Recieve()string{\n\treturn <-nbc.con\n}\n{% endcodeblock %}\n"},{"title":"Go interface","url":"/2018/05/01/Go-interface/","content":"in wikipied what is interface\ncommunicate unrelated object\n\n\n\nGopher china\n\n\n# 基本概念 #\nabtract types\nconcrete type\n\nmemory layout\nbehavior attacherd to data through methods\n\n\ndescrible behavior\n\nthe define a set of methods,withour specifi  revi\n\nabstratatrion\n\nunion of interface\ntwo style\n\nGo proverbs\n\n\nwhy do we use interface\n\nwrit generic algorit\nhindin details\nproviding interceprion points\n\n\nfunc Writer\n\nthe bigger the interface the weaker the abstration\n\nbe conservative in waht you be ,be liberak ub waht you accept\nTCP\n  call dispatch\n\n\nAbstract Data Types\n\nMathmaticak model for data tyoe \ndefined \n\n\n\n\n\n\n\nGo中的接口（interface）不描述数据，它只描述行为，它指定了一个类型（Type）的行为。定义一个interface,使用关键字type和interface,\n\n`type Write interface{\n\twrite([]byte) (int, error)\n}`\n\nType ConsoleWriter struct {}\n和其他语言不同，Go不提供显示implement接口的关键字，而是通过给ConsoleWriter类型绑定一个和接口一样签名的方法来隐式的impelement接口。\n\n    func (cw ConsoleWriter) Write (data []byte) (int, error){\n\t\tn,err:==fmt.println(string(data))\n\t\treturn n,err\n}\n\n命名规则，\n\n# composing interfaces #\n# type conversion #\n## the empty interface ##\n## type switches ##\n# implementing with values vs .pointers #\n\n# best prcatices #"},{"title":"Hello World","url":"/2018/05/01/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]